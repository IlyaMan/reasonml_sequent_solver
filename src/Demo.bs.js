// Generated by BUCKLESCRIPT VERSION 5.0.0, PLEASE EDIT WITH CARE
'use strict';

var Vis = require("vis");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var CamlinternalOO = require("bs-platform/lib/js/camlinternalOO.js");

var shared = ["count"];

var nodes = /* record */[/* contents : array */[]];

var edges = /* record */[/* contents : array */[]];

var options = {
  layout: {
    hierarchical: {
      direction: "UD",
      sortMethod: "directed",
      levelSeparation: 100,
      nodeSpacing: 400
    }
  },
  interaction: {
    dragNodes: false
  },
  physics: {
    enabled: false
  }
};

var testFormulas = /* array */[
  /* Implication */Block.__(4, [
      /* And */Block.__(2, [
          /* Or */Block.__(3, [
              /* Var */Block.__(0, ["x"]),
              /* Var */Block.__(0, ["x"])
            ]),
          /* Or */Block.__(3, [
              /* Var */Block.__(0, ["x"]),
              /* Var */Block.__(0, ["x"])
            ])
        ]),
      /* Or */Block.__(3, [
          /* Var */Block.__(0, ["x"]),
          /* Var */Block.__(0, ["x"])
        ])
    ]),
  /* Not */Block.__(1, [/* Or */Block.__(3, [
          /* Implication */Block.__(4, [
              /* And */Block.__(2, [
                  /* Var */Block.__(0, ["a"]),
                  /* Var */Block.__(0, ["b"])
                ]),
              /* Or */Block.__(3, [
                  /* Var */Block.__(0, ["a"]),
                  /* Var */Block.__(0, ["b"])
                ])
            ]),
          /* Not */Block.__(1, [/* Var */Block.__(0, ["b"])])
        ])]),
  /* And */Block.__(2, [
      /* Implication */Block.__(4, [
          /* Or */Block.__(3, [
              /* Var */Block.__(0, ["x"]),
              /* Var */Block.__(0, ["y"])
            ]),
          /* And */Block.__(2, [
              /* Var */Block.__(0, ["x"]),
              /* Var */Block.__(0, ["y"])
            ])
        ]),
      /* And */Block.__(2, [
          /* Implication */Block.__(4, [
              /* Var */Block.__(0, ["x"]),
              /* Var */Block.__(0, ["y"])
            ]),
          /* Or */Block.__(3, [
              /* Var */Block.__(0, ["x"]),
              /* Var */Block.__(0, ["y"])
            ])
        ])
    ])
];

function join($$char, list) {
  if (list) {
    var tail = list[1];
    var tail$1 = list[0];
    if (tail) {
      return tail$1 + ($$char + join($$char, tail));
    } else {
      return tail$1;
    }
  } else {
    return "";
  }
}

function fToSeq(f) {
  return /* record */[
          /* left : [] */0,
          /* right : :: */[
            f,
            /* [] */0
          ]
        ];
}

function seqToString(seq) {
  var helper = function (formula) {
    switch (formula.tag | 0) {
      case 0 : 
          return formula[0];
      case 1 : 
          return "!" + helper(formula[0]);
      case 2 : 
          return "(" + (helper(formula[0]) + (" && " + (helper(formula[1]) + ")")));
      case 3 : 
          return "(" + (helper(formula[0]) + (" || " + (helper(formula[1]) + ")")));
      case 4 : 
          return "(" + (helper(formula[0]) + (" -> " + (helper(formula[1]) + ")")));
      
    }
  };
  var left = join(", ", List.map(helper, seq[/* left */0]));
  var right = join(", ", List.map(helper, seq[/* right */1]));
  return join(" ", /* :: */[
              left,
              /* :: */[
                "|-",
                /* :: */[
                  right,
                  /* [] */0
                ]
              ]
            ]);
}

function seqsToString(list) {
  return List.map(seqToString, list);
}

function isStraight(seq) {
  var straightLeftChecker = function (a) {
    switch (a.tag | 0) {
      case 1 : 
      case 2 : 
          return true;
      default:
        return false;
    }
  };
  var straihtRightChecker = function (a) {
    switch (a.tag | 0) {
      case 0 : 
      case 2 : 
          return false;
      default:
        return true;
    }
  };
  if (List.exists(straightLeftChecker, seq[/* left */0])) {
    return true;
  } else {
    return List.exists(straihtRightChecker, seq[/* right */1]);
  }
}

function isComplicated(seq) {
  var complicatedLeftChecker = function (f) {
    switch (f.tag | 0) {
      case 3 : 
      case 4 : 
          return true;
      default:
        return false;
    }
  };
  var complicatedRightChecker = function (f) {
    if (f.tag === 2) {
      return true;
    } else {
      return false;
    }
  };
  if (List.exists(complicatedLeftChecker, seq[/* left */0])) {
    return true;
  } else {
    return List.exists(complicatedRightChecker, seq[/* right */1]);
  }
}

function straightProcessor(_seq) {
  while(true) {
    var seq = _seq;
    var straigthLeftFolder = function (acc, el) {
      var toRight = acc[1];
      var left = acc[0];
      switch (el.tag | 0) {
        case 1 : 
            return /* tuple */[
                    left,
                    List.append(toRight, /* :: */[
                          el[0],
                          /* [] */0
                        ])
                  ];
        case 2 : 
            return /* tuple */[
                    List.append(left, /* :: */[
                          el[0],
                          /* :: */[
                            el[1],
                            /* [] */0
                          ]
                        ]),
                    toRight
                  ];
        default:
          return /* tuple */[
                  List.append(left, /* :: */[
                        el,
                        /* [] */0
                      ]),
                  toRight
                ];
      }
    };
    var straightRightFolder = function (acc, el) {
      var right = acc[1];
      var toLeft = acc[0];
      var exit = 0;
      switch (el.tag | 0) {
        case 1 : 
            return /* tuple */[
                    List.append(toLeft, /* :: */[
                          el[0],
                          /* [] */0
                        ]),
                    right
                  ];
        case 0 : 
        case 2 : 
            exit = 1;
            break;
        case 3 : 
            return /* tuple */[
                    toLeft,
                    List.append(right, /* :: */[
                          el[0],
                          /* :: */[
                            el[1],
                            /* [] */0
                          ]
                        ])
                  ];
        case 4 : 
            return /* tuple */[
                    List.append(toLeft, /* :: */[
                          el[0],
                          /* [] */0
                        ]),
                    List.append(right, /* :: */[
                          el[1],
                          /* [] */0
                        ])
                  ];
        
      }
      if (exit === 1) {
        return /* tuple */[
                toLeft,
                List.append(right, /* :: */[
                      el,
                      /* [] */0
                    ])
              ];
      }
      
    };
    var match = List.fold_left(straigthLeftFolder, /* tuple */[
          /* [] */0,
          /* [] */0
        ], seq[/* left */0]);
    var match$1 = List.fold_left(straightRightFolder, /* tuple */[
          /* [] */0,
          /* [] */0
        ], List.append(seq[/* right */1], match[1]));
    var res_000 = /* left */List.append(match$1[0], match[0]);
    var res_001 = /* right */match$1[1];
    var res = /* record */[
      res_000,
      res_001
    ];
    if (isStraight(res)) {
      _seq = res;
      continue ;
    } else {
      return res;
    }
  };
}

function complicatedProcessor(seq) {
  var _prev = /* [] */0;
  var _curr = seq[/* left */0];
  var r = seq[/* right */1];
  while(true) {
    var curr = _curr;
    var prev = _prev;
    if (curr) {
      var tail = curr[1];
      var el = curr[0];
      switch (el.tag | 0) {
        case 3 : 
            return /* :: */[
                    /* record */[
                      /* left */List.append(prev, /* :: */[
                            el[0],
                            tail
                          ]),
                      /* right */r
                    ],
                    /* :: */[
                      /* record */[
                        /* left */List.append(prev, /* :: */[
                              el[1],
                              tail
                            ]),
                        /* right */r
                      ],
                      /* [] */0
                    ]
                  ];
        case 4 : 
            return /* :: */[
                    /* record */[
                      /* left */List.append(prev, /* :: */[
                            el[1],
                            tail
                          ]),
                      /* right */r
                    ],
                    /* :: */[
                      /* record */[
                        /* left */List.append(prev, tail),
                        /* right */List.append(r, /* :: */[
                              el[0],
                              /* [] */0
                            ])
                      ],
                      /* [] */0
                    ]
                  ];
        default:
          _curr = tail;
          _prev = List.append(prev, /* :: */[
                el,
                /* [] */0
              ]);
          continue ;
      }
    } else {
      var _prev$1 = /* [] */0;
      var _curr$1 = r;
      var l = prev;
      while(true) {
        var curr$1 = _curr$1;
        var prev$1 = _prev$1;
        if (curr$1) {
          var tail$1 = curr$1[1];
          var el$1 = curr$1[0];
          if (el$1.tag === 2) {
            return /* :: */[
                    /* record */[
                      /* left */l,
                      /* right */List.append(prev$1, /* :: */[
                            el$1[0],
                            tail$1
                          ])
                    ],
                    /* :: */[
                      /* record */[
                        /* left */l,
                        /* right */List.append(prev$1, /* :: */[
                              el$1[1],
                              tail$1
                            ])
                      ],
                      /* [] */0
                    ]
                  ];
          } else {
            _curr$1 = tail$1;
            _prev$1 = List.append(prev$1, /* :: */[
                  el$1,
                  /* [] */0
                ]);
            continue ;
          }
        } else {
          return /* :: */[
                  /* record */[
                    /* left */l,
                    /* right */prev$1
                  ],
                  /* [] */0
                ];
        }
      };
    }
  };
}

function mainProcessor(seq) {
  var s1 = straightProcessor(seq);
  if (isComplicated(s1)) {
    var s2 = complicatedProcessor(s1);
    return List.flatten(List.map(mainProcessor, s2));
  } else {
    return /* :: */[
            s1,
            /* [] */0
          ];
  }
}

function step(seq) {
  var s1 = straightProcessor(seq);
  if (isComplicated(s1)) {
    return complicatedProcessor(s1);
  } else {
    return /* :: */[
            s1,
            /* [] */0
          ];
  }
}

function axiomCheck(seq) {
  return List.fold_left((function (acc, x) {
                if (List.mem(x, seq[/* right */1])) {
                  return true;
                } else {
                  return acc;
                }
              }), false, seq[/* left */0]);
}

var $$class = CamlinternalOO.create_table(shared);

var ids = CamlinternalOO.new_methods_variables($$class, shared, ["c"]);

var count = ids[0];

var c = ids[1];

CamlinternalOO.set_method($$class, count, (function (self$1, param) {
        self$1[c][0] = self$1[c][0] + 1 | 0;
        return self$1[c][0];
      }));

function obj_init(env) {
  var self = CamlinternalOO.create_object_opt(0, $$class);
  self[c] = /* record */[/* contents */0];
  return self;
}

CamlinternalOO.init_class($$class);

obj_init(0);

var c$1 = /* record */[/* contents */0];

function counter(param) {
  c$1[0] = c$1[0] + 1 | 0;
  return c$1[0];
}

function draw(_seq, _nodeId) {
  while(true) {
    var nodeId = _nodeId;
    var seq = _seq;
    if (isStraight(seq) || isComplicated(seq)) {
      var seqs = step(seq);
      var formulas = List.map(seqToString, seqs);
      var c1 = counter(/* () */0);
      nodes[0] = $$Array.append(/* array */[{
              id: c1,
              label: List.hd(formulas)
            }], nodes[0]);
      edges[0] = $$Array.append(/* array */[{
              from: nodeId,
              to: c1
            }], edges[0]);
      draw(List.hd(seqs), c1);
      if (List.length(formulas) === 2) {
        var c2 = counter(/* () */0);
        nodes[0] = $$Array.append(/* array */[{
                id: c2,
                label: List.hd(List.tl(formulas))
              }], nodes[0]);
        edges[0] = $$Array.append(/* array */[{
                from: nodeId,
                to: c2
              }], edges[0]);
        _nodeId = c2;
        _seq = List.hd(List.tl(seqs));
        continue ;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  };
}

function starter(f) {
  var badPrinter = function (res) {
    console.log("Counterexample:");
    var seq = List.find((function (s) {
            return !axiomCheck(s);
          }), res);
    var helperPrinter = function (num, el) {
      if (el.tag) {
        console.log(el, num);
        return /* () */0;
      } else {
        console.log(el[0], "=", num);
        return /* () */0;
      }
    };
    List.iter((function (param) {
            return helperPrinter(1, param);
          }), seq[/* left */0]);
    List.iter((function (param) {
            return helperPrinter(0, param);
          }), seq[/* right */1]);
    console.log("Unlisted variables (if any) may possess any value");
    return /* () */0;
  };
  var seq_001 = /* right : :: */[
    f,
    /* [] */0
  ];
  var seq = /* record */[
    /* left : [] */0,
    seq_001
  ];
  var res = mainProcessor(seq);
  var match = List.fold_left((function (acc, seq) {
          if (axiomCheck(seq)) {
            return acc;
          } else {
            return false;
          }
        }), true, res);
  if (match) {
    console.log("Tautology");
  } else {
    badPrinter(res);
  }
  nodes[0] = $$Array.append(/* array */[{
          id: 0,
          label: seqToString(seq)
        }], nodes[0]);
  return draw(fToSeq(f), 0);
}

starter(Caml_array.caml_array_get(testFormulas, 2));

var data = {
  nodes: new Vis.DataSet(nodes[0]),
  edges: new Vis.DataSet(edges[0])
};

var network = new Vis.Network(Caml_option.nullable_to_opt(document.getElementById("mynetwork")), data, options);

var allRulesTestingSequent = /* record */[
  /* left : :: */[
    /* Implication */Block.__(4, [
        /* Var */Block.__(0, ["r"]),
        /* Var */Block.__(0, ["l"])
      ]),
    /* :: */[
      /* Var */Block.__(0, ["x"]),
      /* :: */[
        /* Not */Block.__(1, [/* Var */Block.__(0, ["a"])]),
        /* :: */[
          /* And */Block.__(2, [
              /* Var */Block.__(0, ["c"]),
              /* Var */Block.__(0, ["d"])
            ]),
          /* :: */[
            /* Or */Block.__(3, [
                /* Var */Block.__(0, ["n"]),
                /* Var */Block.__(0, ["f"])
              ]),
            /* [] */0
          ]
        ]
      ]
    ]
  ],
  /* right : :: */[
    /* Implication */Block.__(4, [
        /* Var */Block.__(0, ["m"]),
        /* Var */Block.__(0, ["w"])
      ]),
    /* :: */[
      /* Var */Block.__(0, ["y"]),
      /* :: */[
        /* Not */Block.__(1, [/* Var */Block.__(0, ["b"])]),
        /* :: */[
          /* And */Block.__(2, [
              /* Var */Block.__(0, ["q"]),
              /* Var */Block.__(0, ["p"])
            ]),
          /* :: */[
            /* Or */Block.__(3, [
                /* Var */Block.__(0, ["z"]),
                /* Var */Block.__(0, ["t"])
              ]),
            /* [] */0
          ]
        ]
      ]
    ]
  ]
];

exports.nodes = nodes;
exports.edges = edges;
exports.options = options;
exports.testFormulas = testFormulas;
exports.join = join;
exports.fToSeq = fToSeq;
exports.seqToString = seqToString;
exports.seqsToString = seqsToString;
exports.isStraight = isStraight;
exports.isComplicated = isComplicated;
exports.straightProcessor = straightProcessor;
exports.complicatedProcessor = complicatedProcessor;
exports.mainProcessor = mainProcessor;
exports.step = step;
exports.axiomCheck = axiomCheck;
exports.allRulesTestingSequent = allRulesTestingSequent;
exports.counter = counter;
exports.draw = draw;
exports.starter = starter;
exports.data = data;
exports.network = network;
/* class Not a pure module */
